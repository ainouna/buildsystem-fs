--- a/include/dvbsi++/byte_stream.h
+++ b/include/dvbsi++/byte_stream.h
@@ -23,8 +23,21 @@
 #define w32(p,v)	do { *(uint32_t * const)(p) = ((const uint32_t)v) } while (0)
 #define w64(p,v)	do { *(uint64_t * const)(p) = ((const uint64_t)v) } while (0)
 #else
+#ifdef __sh__
+/* Dagobert / Phantomias: sh4 cant access u16/u32 on unaligned address */
+#define r8(p)           (*(const __uint8_t * const)(p))
+
+#define r16(p)          (r8((const __uint8_t * const) p + 0) << 8 | \
+                        r8((const __uint8_t * const) p + 1))
+
+#define r32(p)          (r8((const __uint8_t * const) p + 0) << 24 | \
+                        r8((const __uint8_t * const) p + 1) << 16 | \
+                        r8((const __uint8_t * const) p + 2) << 8 | \
+                        r8((const __uint8_t * const) p + 3))
+#else
 #define r16(p)		bswap_16(*(const uint16_t * const)p)
 #define r32(p)		bswap_32(*(const uint32_t * const)p)
+#endif
 #define r64(p)		bswap_64(*(const uint64_t * const)p)
 #define w16(p,v)	do { *(uint16_t * const)(p) = bswap_16((const uint16_t)v) } while (0)
 #define w32(p,v)	do { *(uint32_t * const)(p) = bswap_32((const uint32_t)v) } while (0)
--- a/src/time_date_section.cpp
+++ b/src/time_date_section.cpp
@@ -15,7 +15,7 @@
 
 TimeAndDateSection::TimeAndDateSection(const uint8_t * const buffer) : ShortSection(buffer)
 {
-	if (sectionLength > 8) {
+	if (sectionLength >= 5) {
 		utcTimeMjd = UINT16(&buffer[3]);
 		utcTimeBcd = (buffer[5] << 16) | UINT16(&buffer[6]);
 	}
--- a/src/content_identifier_descriptor.cpp
+++ b/src/content_identifier_descriptor.cpp
@@ -69,6 +69,8 @@
 			i += crid->getLength() + 2;
 		else if (crid->getLocation() == 1)
 			i += 3;
+		else
+			return; // probably wrong, but better than an endless loop ... --martii
 
 		identifier.push_back(crid);
 	}
--- a/src/dts_descriptor.cpp
+++ b/src/dts_descriptor.cpp
@@ -16,10 +16,10 @@
 	ASSERT_MIN_DLEN(5);
 
 	sampleRate = (buffer[2] >> 4) & 0x0f;
-	bitRate = ((buffer[2] & 0x0f) << 2) | (buffer[3] >> 6) & 0x02;
-	numberOfBlocks = ((buffer[3] & 0x3f) << 2) | (buffer[4] >> 7) & 0x01;
+	bitRate = ((buffer[2] & 0x0f) << 2) | ((buffer[3] >> 6) & 0x03);
+	numberOfBlocks = ((buffer[3] & 0x3f) << 1) | ((buffer[4] >> 7) & 0x01);
 	frameSize = ((buffer[4] & 0x7f) << 7) | (buffer[5] >> 1);
-	surroundMode = ((buffer[5] & 0x01) << 6) | (buffer[6] >> 3) & 0x1f;
+	surroundMode = ((buffer[5] & 0x01) << 5) | ((buffer[6] >> 3) & 0x1f);
 	lfeFlag = (buffer[6] >> 2) & 0x01;
 	extendedSurroundFlag = buffer[6] & 0x03;
 
--- a/src/application_information_section.cpp
+++ b/src/application_information_section.cpp
@@ -15,12 +15,20 @@
 
 ApplicationInformation::ApplicationInformation(const uint8_t * const buffer)
 {
+	unsigned int length;
+
 	applicationIdentifier = new ApplicationIdentifier(&buffer[0]);
 	applicationControlCode = buffer[6];
 	applicationDescriptorsLoopLength = DVB_LENGTH(&buffer[7]);
 
-	for (size_t i = 0; i < applicationDescriptorsLoopLength; i += buffer[i + 10] + 2)
+	for (size_t i = 0; i < applicationDescriptorsLoopLength; i += length) {
+		if (i + 2 > applicationDescriptorsLoopLength)
+			break;
+		length = buffer[i + 10] + 2;
+		if (i + length > applicationDescriptorsLoopLength)
+			break;
 		descriptor(&buffer[i + 9], SCOPE_MHP);
+	}
 }
 
 ApplicationInformation::~ApplicationInformation(void)
@@ -38,35 +46,43 @@
 	return applicationControlCode;
 }
 
-ApplicationInformationSection::ApplicationInformationSection(const uint8_t * const buffer) : LongCrcSection(buffer)
+ApplicationInformationSection::ApplicationInformationSection(const uint8_t * const buffer) : LongCrcSection(buffer),
+	commonDescriptorsLength(0),
+	applicationLoopLength(0)
 {
-	commonDescriptorsLength = sectionLength > 10 ? DVB_LENGTH(&buffer[8]) : 0;
+	unsigned int pos, length;
 
-	uint16_t pos = 10;
-	uint16_t bytesLeft = sectionLength > 11 ? sectionLength - 11 : 0;
-	uint16_t loopLength = 0;
-	uint16_t bytesLeft2 = commonDescriptorsLength;
+	if (sectionLength < 13)
+		return;
 
-	while (bytesLeft >= bytesLeft2 && bytesLeft2 > 1 && bytesLeft2 >= (loopLength = 2 + buffer[pos+1])) {
+	commonDescriptorsLength = DVB_LENGTH(&buffer[8]);
+	if (sectionLength < 13 + commonDescriptorsLength)
+		return;
+
+	for (pos = 10; pos < 10 + commonDescriptorsLength; pos += length) {
+		if (pos + 2 > 10 + commonDescriptorsLength)
+			break;
+		length = buffer[pos + 1] + 2;
+		if (pos + length > 10 + commonDescriptorsLength)
+			break;
 		descriptor(&buffer[pos], SCOPE_MHP);
-		pos += loopLength;
-		bytesLeft -= loopLength;
-		bytesLeft2 -= loopLength;
 	}
 
-	if (!bytesLeft2 && bytesLeft > 1) {
-		bytesLeft2 = applicationLoopLength = DVB_LENGTH(&buffer[pos]);
-		pos+=2;
-		bytesLeft-=2;
-		while (bytesLeft >= bytesLeft2 && bytesLeft2 > 8 && bytesLeft2 >= (loopLength = 9 + DVB_LENGTH(&buffer[pos+7]))) {
-			applicationInformation.push_back(new ApplicationInformation(&buffer[pos]));
-			pos += loopLength;
-			bytesLeft -= loopLength;
-			bytesLeft2 -= loopLength;
-		}
+	if (pos != 10 + commonDescriptorsLength)
+		return;
+
+	applicationLoopLength = DVB_LENGTH(&buffer[pos]);
+	if (sectionLength < 13 + commonDescriptorsLength + applicationLoopLength)
+		return;
+
+	for (pos += 2; pos < 12 + commonDescriptorsLength + applicationLoopLength; pos += length) {
+		if (pos + 9 > 12 + commonDescriptorsLength + applicationLoopLength)
+			break;
+		length = DVB_LENGTH(&buffer[pos + 7]) + 9;
+		if (pos + length > 12 + commonDescriptorsLength + applicationLoopLength)
+			break;
+		applicationInformation.push_back(new ApplicationInformation(&buffer[pos]));
 	}
-	else
-		applicationLoopLength = 0;
 }
 
 ApplicationInformationSection::~ApplicationInformationSection(void)
